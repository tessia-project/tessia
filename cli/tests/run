#!/usr/bin/env python3
# Copyright 2017 IBM Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Entry point to execute the testcases
"""

#
# IMPORTS
#
from util.static_executor import STATIC_DIR, StaticExecutor

import click
import os
import requests
import subprocess
import time

#
# CONSTANTS AND DEFINITIONS
#
CMD_COVERAGE = 'python3 -m coverage run -a --source=../tessia_cli {}'
CMD_COVERAGE_ERASE = "python3 -m coverage erase"
CMD_COVERAGE_REPORT = "python3 -m coverage report -m"
CMD_WRAPPER = '-m tests.wrapper {test_name} {api_url}'
MY_DIR = os.path.dirname(os.path.abspath(__file__))

#
# CODE
#
def _build_test_list():
    """
    Create a dictionary containing all the testcases found in the corresponding
    folder.
    """
    test_map = {}

    for entry in os.listdir(STATIC_DIR):
        if not entry.endswith('.yaml'):
            continue

        test_name = entry[:-5]
        testcase = StaticExecutor.load_testcase(test_name)
        test_map[test_name] = testcase['description']

    return test_map
# _build_test_list()

@click.command('exec')
@click.option(
    'names', '--name', multiple=True,
    help="testcase to execute; can be specified multiple times")
@click.option(
    'api_url', '--api-url', required=True,
    help="url where API is running")
@click.option(
    'cleaner', '--cleaner', type=click.Path(exists=True, resolve_path=True),
    help="cleaner hook to use before each testcase")
def exec_(names, api_url, cleaner):
    """
    execute one or more testcases
    """
    fix_map = _build_test_list()

    # build the list of tests to execute
    run_list = []
    if not names:
        run_list = fix_map.keys()
    else:
        for testcase in names:
            try:
                fix_map[testcase]
            except KeyError:
                raise click.ClickException(
                    "unknown testcase '{}'".format(testcase))
            run_list.append(testcase)
    click.echo('[init] testcases to execute: {}'.format(', '.join(run_list)))

    os.chdir(MY_DIR)
    subprocess.run(CMD_COVERAGE_ERASE, shell=True, check=1)

    # run each testcase
    for test_name in run_list:
        if cleaner is not None:
            click.echo("[pre-start] calling cleaner '{}'".format(cleaner))
            clean_status = subprocess.call(cleaner, shell=True)
            if clean_status != 0:
                raise click.ClickException(
                    'cleaner failed with exit code {}'.format(clean_status))
        # make sure connection is back, sometimes there is a delay
        timeout = time.time() + 30
        failed = True
        while time.time() < timeout:
            try:
                requests.head(api_url, verify=False)
            except requests.exceptions.HTTPError:
                pass
            except requests.exceptions.ConnectionError:
                continue
            except Exception:
                raise
            failed = False
            break
        if failed:
            raise click.ClickException('Timed out while waiting for server')

        # switch to parent dir to make sure paths are found
        exec_cmd = CMD_WRAPPER.format(
            test_name=test_name, api_url=api_url)
        cmd_str = CMD_COVERAGE.format(exec_cmd)

        click.echo('[exec] {}'.format(cmd_str))
        # execute and return exit code
        result = subprocess.run(
            cmd_str, shell=True, stderr=subprocess.STDOUT, check=0)
        if result.returncode != 0:
            click.echo(result.stdout)
            raise click.ClickException(
                "testcase '{}' failed with exit code {}".format(
                    test_name, result.returncode)
            )

        click.echo("finished testcase '{}'".format(test_name))

    subprocess.run(CMD_COVERAGE_REPORT, shell=True, check=1)
# exec_()

@click.command('list')
def list_():
    """
    list the available testcases
    """
    headers = ['Testcase', 'Description']
    rows = [(test, desc) for test, desc in _build_test_list().items()]

    # determine biggest width for each column
    cols_width = [(len(header) + 2) for header in headers]
    for row in rows:
        for i in range(0, len(row)):
            row_width = len(row[i]) + 2
            if row_width > cols_width[i]:
                cols_width[i] = row_width

    output_cols = []
    output_sep = []
    for i in range(0, len(headers)):
        output_cols.append(headers[i].center(cols_width[i]))
        sep = '-' * cols_width[i]
        output_sep.append(sep)
    output = '\n' + '|'.join(output_cols)
    output += '\n'
    output += '+'.join(output_sep)
    # print rows
    for row in rows:
        output_row = []
        for i in range(0, len(row)):
            output_value = ' {}'.format(row[i])
            output_row.append(output_value.ljust(cols_width[i]))

        output += '\n{}'.format('|'.join(output_row))
    click.echo(output)
# list_()

@click.group()
def root():
    """
    Tessia cmdline client test runner
    """
    pass
# root()

def main():
    """
    Entry point, executes the root group.
    """
    root.add_command(exec_)
    root.add_command(list_)
    root()
# main()

if __name__ == '__main__':
    main()
